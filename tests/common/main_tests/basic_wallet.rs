use monero::{Address, Network};
use monero_rpc::{GenerateFromKeysArgs, AddressData, SubaddressData};

use crate::common::helpers;

pub async fn test() {
    let (_, _, wallet) = helpers::setup_monero();

    helpers::wallet::get_version(&wallet).await;

    let (wallet_with_pwd, wallet_with_no_pwd, wallet_with_empty_pwd) = tokio::join!(
        helpers::wallet::create_wallet_with_password(&wallet, helpers::PWD_1),
        helpers::wallet::create_wallet_with_no_password_parameter(&wallet),
        helpers::wallet::create_wallet_with_empty_password(&wallet),
    );
    helpers::wallet::create_wallet_error_already_exists(&wallet, &wallet_with_pwd).await;
    helpers::wallet::create_wallet_error_invalid_language(&wallet).await;

    helpers::wallet::close_wallet(&wallet).await;
    helpers::wallet::close_wallet_error_no_wallet_file(&wallet).await;

    // open same wallet twice
    helpers::wallet::open_wallet_with_password(&wallet, &wallet_with_pwd, helpers::PWD_1).await;
    helpers::wallet::open_wallet_with_password(&wallet, &wallet_with_pwd, helpers::PWD_1).await;

    helpers::wallet::open_wallet_with_no_or_empty_password(&wallet, &wallet_with_no_pwd).await;
    helpers::wallet::open_wallet_with_no_or_empty_password(&wallet, &wallet_with_empty_pwd).await;

    helpers::wallet::open_wallet_error_filename_invalid(&wallet, "troll_wallet").await;
    helpers::wallet::open_wallet_error_wrong_password(&wallet, &wallet_with_pwd, None).await;
    helpers::wallet::open_wallet_error_wrong_password(
        &wallet,
        &wallet_with_no_pwd,
        Some("wrong_password :)".to_string()),
    )
    .await;

    let key_pair_1 = helpers::get_keypair_1();
    let generate_wallet_args_1 = GenerateFromKeysArgs {
        restore_height: None,
        filename: "".to_string(), // empty because will be generated by the below function call
        address: Address::from_keypair(Network::Mainnet, &key_pair_1),
        spendkey: None,
        viewkey: key_pair_1.view,
        password: "".to_string(),
        autosave_current: None,
    };
    let _ = helpers::wallet::generate_from_keys(&wallet, generate_wallet_args_1.clone()).await;
    // creating wallet again, but with a different name, causes no error
    let wallet_creation_from_key_pair_1 =
        helpers::wallet::generate_from_keys(&wallet, generate_wallet_args_1).await;

    let key_pair_2 = helpers::get_keypair_2();
    let generate_wallet_args_2 = GenerateFromKeysArgs {
        restore_height: Some(0),
        filename: "".to_string(), // empty because will be generated by the below function call
        address: Address::from_keypair(Network::Mainnet, &key_pair_2),
        spendkey: Some(key_pair_2.spend),
        viewkey: key_pair_2.view,
        password: helpers::PWD_1.to_string(),
        autosave_current: Some(false),
    };
    let wallet_creation_from_key_pair_2 =
        helpers::wallet::generate_from_keys(&wallet, generate_wallet_args_2).await;

    let key_pair_3 = helpers::get_keypair_3();
    let generate_wallet_args_3 = GenerateFromKeysArgs {
        restore_height: None,
        filename: wallet_with_empty_pwd,
        address: Address::from_keypair(Network::Mainnet, &key_pair_3),
        spendkey: Some(key_pair_3.spend),
        viewkey: key_pair_3.view,
        password: "".to_string(),
        autosave_current: None,
    };
    helpers::wallet::generate_from_keys_error_filename_already_exists(
        &wallet,
        generate_wallet_args_3,
    )
    .await;
    let generate_wallet_args_3 = GenerateFromKeysArgs {
        restore_height: Some(u64::MAX),
        filename: "".to_string(), // empty because will be generated by the below function call
        address: Address::from_keypair(Network::Mainnet, &key_pair_3),
        spendkey: Some(key_pair_3.spend),
        viewkey: key_pair_3.view,
        password: "".to_string(),
        autosave_current: None,
    };
    // invalid restore_height returns no error
    let wallet_creation_from_key_pair_3 =
        helpers::wallet::generate_from_keys(&wallet, generate_wallet_args_3).await;
    let generate_wallet_args_3 = GenerateFromKeysArgs {
        restore_height: None,
        filename: "".to_string(), // empty because will be generated by the below function call
        address: Address::from_keypair(Network::Testnet, &key_pair_3),
        spendkey: Some(key_pair_3.spend),
        viewkey: key_pair_3.view,
        password: "".to_string(),
        autosave_current: None,
    };
    // generate from invalid address
    helpers::wallet::generate_from_keys_error_invalid_address(&wallet, generate_wallet_args_3)
        .await;

    helpers::wallet::close_wallet(&wallet).await;
    helpers::wallet::get_address_error_no_wallet_file(&wallet).await;

    helpers::wallet::open_wallet_with_no_or_empty_password(
        &wallet,
        &wallet_creation_from_key_pair_1.0,
    )
    .await;
    helpers::wallet::get_address_error_invalid_account_index(&wallet, 10).await;
    helpers::wallet::get_address_error_invalid_address_index(&wallet, 0, Some(vec![10])).await;

    let expected_get_address_from_key_pair_1_subaddress_data = SubaddressData {
        address: wallet_creation_from_key_pair_1.1.address,
        address_index: 0,
        label: "Primary account".to_string(),
        used: false,
    };
    let expected_get_address_from_key_pair_1 = AddressData {
        address: wallet_creation_from_key_pair_1.1.address,
        addresses: vec![
            expected_get_address_from_key_pair_1_subaddress_data.clone(),
            expected_get_address_from_key_pair_1_subaddress_data.clone(),
            expected_get_address_from_key_pair_1_subaddress_data,
        ],
    };
    helpers::wallet::get_address(
        &wallet,
        0,
        Some(vec![0, 0, 0]),
        expected_get_address_from_key_pair_1,
    )
    .await;

    helpers::wallet::get_address_index(&wallet, wallet_creation_from_key_pair_1.1.address, (0, 0))
        .await;
    // get address from wallet different than the one opened
    helpers::wallet::get_address_index_error_address_from_another_wallet(
        &wallet,
        wallet_creation_from_key_pair_2.1.address,
    )
    .await;
    helpers::wallet::get_address_index_error_invalid_address(
        &wallet,
        Address::from_keypair(Network::Testnet, &key_pair_1),
    )
    .await;
}
