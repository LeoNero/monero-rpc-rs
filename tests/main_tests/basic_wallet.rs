use monero::{
    cryptonote::subaddress::{self, Index},
    Address, Amount, Network, ViewPair,
};
use monero_rpc::{AddressData, GenerateFromKeysArgs, GetAccountsData, GotAccount, SubaddressData};

use super::helpers;

pub async fn test() {
    let (_, _, wallet) = helpers::setup_monero();

    helpers::wallet::get_version(&wallet).await;

    let (wallet_with_pwd, wallet_with_no_pwd, wallet_with_empty_pwd) = tokio::join!(
        helpers::wallet::create_wallet_with_password(&wallet, helpers::PWD_1),
        helpers::wallet::create_wallet_with_no_password_parameter(&wallet),
        helpers::wallet::create_wallet_with_empty_password(&wallet),
    );
    helpers::wallet::create_wallet_error_already_exists(&wallet, &wallet_with_pwd).await;
    helpers::wallet::create_wallet_error_invalid_language(&wallet).await;

    helpers::wallet::close_wallet(&wallet).await;
    helpers::wallet::close_wallet_error_no_wallet_file(&wallet).await;

    // open same wallet twice
    helpers::wallet::open_wallet_with_password(&wallet, &wallet_with_pwd, helpers::PWD_1).await;
    helpers::wallet::open_wallet_with_password(&wallet, &wallet_with_pwd, helpers::PWD_1).await;

    helpers::wallet::open_wallet_with_no_or_empty_password(&wallet, &wallet_with_no_pwd).await;
    helpers::wallet::open_wallet_with_no_or_empty_password(&wallet, &wallet_with_empty_pwd).await;

    helpers::wallet::open_wallet_error_filename_invalid(&wallet, "troll_wallet").await;
    helpers::wallet::open_wallet_error_wrong_password(&wallet, &wallet_with_pwd, None).await;
    helpers::wallet::open_wallet_error_wrong_password(
        &wallet,
        &wallet_with_no_pwd,
        Some("wrong_password :)".to_string()),
    )
    .await;

    let key_pair_1 = helpers::get_keypair_1();
    let generate_wallet_args_1 = GenerateFromKeysArgs {
        restore_height: None,
        filename: "".to_string(), // empty because will be generated by the below function call
        address: Address::from_keypair(Network::Mainnet, &key_pair_1),
        spendkey: None,
        viewkey: key_pair_1.view,
        password: "".to_string(),
        autosave_current: None,
    };
    let _ = helpers::wallet::generate_from_keys(&wallet, generate_wallet_args_1.clone()).await;
    // creating wallet again, but with a different name, causes no error
    let wallet_creation_from_key_pair_1 =
        helpers::wallet::generate_from_keys(&wallet, generate_wallet_args_1).await;

    let key_pair_2 = helpers::get_keypair_2();
    let generate_wallet_args_2 = GenerateFromKeysArgs {
        restore_height: Some(0),
        filename: "".to_string(), // empty because will be generated by the below function call
        address: Address::from_keypair(Network::Mainnet, &key_pair_2),
        spendkey: Some(key_pair_2.spend),
        viewkey: key_pair_2.view,
        password: helpers::PWD_1.to_string(),
        autosave_current: Some(false),
    };
    let wallet_creation_from_key_pair_2 =
        helpers::wallet::generate_from_keys(&wallet, generate_wallet_args_2).await;

    let key_pair_3 = helpers::get_keypair_3();
    let generate_wallet_args_3 = GenerateFromKeysArgs {
        restore_height: None,
        filename: wallet_with_empty_pwd,
        address: Address::from_keypair(Network::Mainnet, &key_pair_3),
        spendkey: Some(key_pair_3.spend),
        viewkey: key_pair_3.view,
        password: "".to_string(),
        autosave_current: None,
    };
    helpers::wallet::generate_from_keys_error_filename_already_exists(
        &wallet,
        generate_wallet_args_3,
    )
    .await;
    let generate_wallet_args_3 = GenerateFromKeysArgs {
        restore_height: Some(u64::MAX),
        filename: "".to_string(), // empty because will be generated by the below function call
        address: Address::from_keypair(Network::Mainnet, &key_pair_3),
        spendkey: Some(key_pair_3.spend),
        viewkey: key_pair_3.view,
        password: "".to_string(),
        autosave_current: None,
    };
    // invalid restore_height returns no error
    let _ = helpers::wallet::generate_from_keys(&wallet, generate_wallet_args_3).await;
    let generate_wallet_args_3 = GenerateFromKeysArgs {
        restore_height: None,
        filename: "".to_string(), // empty because will be generated by the below function call
        address: Address::from_keypair(Network::Testnet, &key_pair_3),
        spendkey: Some(key_pair_3.spend),
        viewkey: key_pair_3.view,
        password: "".to_string(),
        autosave_current: None,
    };
    // generate from invalid address
    helpers::wallet::generate_from_keys_error_invalid_address(&wallet, generate_wallet_args_3)
        .await;

    helpers::wallet::close_wallet(&wallet).await;
    helpers::wallet::get_address_error_no_wallet_file(&wallet).await;

    helpers::wallet::open_wallet_with_no_or_empty_password(
        &wallet,
        &wallet_creation_from_key_pair_1.0,
    )
    .await;
    helpers::wallet::get_address_error_invalid_account_index(&wallet, 10).await;
    helpers::wallet::get_address_error_invalid_address_index(&wallet, 0, Some(vec![10])).await;

    let expected_get_address_from_key_pair_1_subaddress_data = SubaddressData {
        address: wallet_creation_from_key_pair_1.1.address,
        address_index: 0,
        label: "Primary account".to_string(),
        used: false,
    };
    let expected_get_address_from_key_pair_1 = AddressData {
        address: wallet_creation_from_key_pair_1.1.address,
        addresses: vec![
            expected_get_address_from_key_pair_1_subaddress_data.clone(),
            expected_get_address_from_key_pair_1_subaddress_data.clone(),
            expected_get_address_from_key_pair_1_subaddress_data,
        ],
    };
    helpers::wallet::get_address(
        &wallet,
        0,
        Some(vec![0, 0, 0]),
        expected_get_address_from_key_pair_1,
    )
    .await;

    helpers::wallet::get_address_index(
        &wallet,
        wallet_creation_from_key_pair_1.1.address,
        Index { major: 0, minor: 0 },
    )
    .await;
    // get address from wallet different than the one opened
    helpers::wallet::get_address_index_error_address_from_another_wallet(
        &wallet,
        wallet_creation_from_key_pair_2.1.address,
    )
    .await;
    helpers::wallet::get_address_index_error_invalid_address(
        &wallet,
        Address::from_keypair(Network::Testnet, &key_pair_1),
    )
    .await;

    // open a different wallet for the next few tests
    helpers::wallet::open_wallet_with_password(
        &wallet,
        &wallet_creation_from_key_pair_2.0,
        helpers::PWD_1,
    )
    .await;

    let expected_first_new_address = (
        subaddress::get_subaddress(
            &ViewPair::from(&key_pair_2),
            subaddress::Index { major: 0, minor: 1 },
            Some(Network::Mainnet),
        ),
        1,
    );
    let first_new_address_for_wallet_from_key_pair_2 =
        helpers::wallet::create_address(&wallet, 0, None, expected_first_new_address).await;

    let expected_second_new_address = (
        subaddress::get_subaddress(
            &ViewPair::from(&key_pair_2),
            subaddress::Index { major: 0, minor: 2 },
            Some(Network::Mainnet),
        ),
        2,
    );
    let second_new_address_for_wallet_from_key_pair_2 = helpers::wallet::create_address(
        &wallet,
        0,
        Some("new_label".to_string()),
        expected_second_new_address,
    )
    .await;
    helpers::wallet::create_address_error_invalid_account_index(&wallet, 10).await;

    helpers::wallet::label_address(
        &wallet,
        Index {
            major: 0,
            minor: first_new_address_for_wallet_from_key_pair_2.1,
        },
        "haha label :)".to_string(),
    )
    .await;
    helpers::wallet::label_address(
        &wallet,
        Index {
            major: 0,
            minor: second_new_address_for_wallet_from_key_pair_2.1,
        },
        "".to_string(),
    )
    .await;

    helpers::wallet::label_address_error_invalid_account_index(
        &wallet,
        Index {
            major: 10,
            minor: 0,
        },
    )
    .await;
    helpers::wallet::label_address_error_invalid_address_index(
        &wallet,
        Index {
            major: 0,
            minor: 10,
        },
    )
    .await;

    let expected_got_account_main_address = GotAccount {
        account_index: 0,
        balance: Amount::from_pico(0),
        base_address: Address::from_keypair(Network::Mainnet, &key_pair_2),
        label: Some("Primary account".to_string()),
        tag: Some("".to_string()),
        unlocked_balance: Amount::from_pico(0),
    };
    helpers::wallet::get_accounts(
        &wallet,
        None,
        GetAccountsData {
            subaddress_accounts: vec![expected_got_account_main_address],
            total_balance: Amount::from_pico(0),
            total_unlocked_balance: Amount::from_pico(0),
        },
    )
    .await;
    helpers::wallet::get_accounts_error_unregistered_tag(
        &wallet,
        "no_account_with this_tag".to_string(),
    )
    .await;

    helpers::wallet::close_wallet(&wallet).await;
}
